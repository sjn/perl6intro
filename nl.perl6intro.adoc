= Perl 6 Inleiding
Naoum Hankache <naoum@hankache.com>; Elizabeth Mattijsen <perl6intro@liz.nl>
:description: Een algemene inleiding van Perl 6
:keywords: perl6, perl 6, inleiding, perl6intro, perl 6 inleiding, perl 6 tutorial, perl 6 intro
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book
:lang: nl

Dit document is bedoeld om je een kort overzicht te geven van de Perl 6 programmeertaal.
Het is zo opgezet dat je snel leert iets met Perl 6 te kunnen doen.

Sommige onderdelen van dit document verwijzen aan (completere en preciezere) delen van de (Engelstalige) http://docs.perl6.org[Perl 6 documentatie].
Als je meer informatie over een bepaald onderwerp nodig hebt, is dat de beste plaats om die te vinden.

Je zult voorbeelden vinden bij de meeste onderwerpen in dit document.
Neem de tijd om ze allemaal uit te proberen om ze beter te begrijpen.

.Licentie
De inhoud is gelicenseerd met de Creative Commons Attribution-ShareAlike 4.0 International License.
Om deze in te zien, ga naar

* https://creativecommons.org/licenses/by-sa/4.0/.

.Bijdragen
Als je wilt bijdragen aan dit document, ga dan naar:

* https://github.com/hankache/perl6intro

.Feedback
Alle feedback is welkom:

* naoum@hankache.com - Engels
* perl6intro@liz.nl - Nederlands

:sectnums:
== Inleiding
=== Wat is Perl 6
Perl 6 is een hogere programmeertaal voor algemeen gebruik met graduele typering.
In Perl 6 kan met diverse paradigma's geprogrammeerd worden.  Ondersteund worden onder andere procedureel, object-georienteerd en functioneel programmeren.

.Perl 6 motto:
* TIMTOWTDI (uitgesproken "Timtoodi", oftewel "TimToady" in het Engels): There Is More Than One Way To Do It. (Er is meer dan 1 manier om het te doen)
* Gemakkelijke dingen moeten gemakkelijk blijven, moeilijke dingen moeten gemakkelijker worden en onmogelijk dingen moeten slechts moeilijk zijn.

=== Jargon
* *Perl 6*: Is een taalspecificatie met een verzameling tests.
Een implementatie van Perl 6 die al deze tests succesvol kan uitvoeren, mag zich een "Perl 6" implementatie noemen.
* *Rakudo*: Is een compiler voor Perl 6.
* *Rakudobrew*: Is een installatie-manager van Perl 6.
* *Panda*: Is een installatie-programma voor modules.
* *Rakudo Star*: Is een bundel software waarin zich Rakudo, Panda, documentatie en een verzameling van Perl 6 modules bevindt.

=== Installeren van Perl 6
.Linux
. Installeer Rakudobrew: https://github.com/tadzik/rakudobrew

. Installeer Rakudo: Type het volgende commando in een terminalvenster `rakudobrew build moar`

. Installeer Panda: Type het volgende commando in een terminalvenster `rakudobrew build panda`

.OSX
OS X kent vier mogelijkheden:

* Volg dezelfde stappen als voor Linux

* Installeer met homebrew: `brew install rakudo-star`

* Installeer met MacPorts: `sudo port install rakudo`

* Download de meest recente installer (bestand met .dmg extensie) van http://rakudo.org/downloads/star/

.Windows
. Download de meest recenter installer (bestand met .msi extensie) van http://rakudo.org/downloads/star/ +
Op een 32-bit systeem, download het bestand met x86; op een 64-bit, download dan het x86_64 bestand.
. Zorg ervoor dat `C:\rakudo\bin` in je PATH is na het installeren.

.Docker
. Gebruik het officiele Docker image `docker pull rakudo-star`
. Voer dan een container uit met het image `docker run -it rakudo-star`

=== Uitvoeren van Perl 6 code

Je kunt eenvoudig Perl 6 code uitvoeren in de REPL (Read-Eval-Print-Loop,
oftewel een lees, evalueer, print, lus).
Om dit te doen open je een terminal venster, type `perl6` en druk op [Enter].  Er verschijnt dan een `>` prompt.
Vervolgens kun je een regel code intypen en weer op [Enter] drukken.  De REPL zal dan de uiteindelijke waarde van die code afdrukken.  Je kunt dan weer een regel code intypen, of `exit` intypen en op [Enter] drukken om de REPL te verlaten.

Een andere mogelijkheid is om je code in een bestand op te slaan en dan uit te voeren.
Het wordt aangeraden om een Perl 6 script de extensie `.pl6` te geven.
Voer het bestand uit door `perl6 bestandsnaam.pl6` in het terminal venster in te typen en op [Enter] te drukken.  Anders dan bij de REPL zal die niet automatisch het resultaat van elke regel afdrukken: daarvoor moet je een opdracht als `say` in je programma plaatsen om iets af te drukken.

De REPL wordt meestal gebruikt om een specifiek stukje code uit te proberen, meestal niet meer dan een enkele regel.  Voor programma's die uit meer dan een regel bestaan, wordt het aangeraden om die regels in een bestand op te slaan en dan dat bestand uit te voeren.

Je kunt ook een regel code non-interactief uitproberen op de commando-regel in een terminal venster met `perl6 -e 'jouw regel code'` in te typen en dan op [Enter] te drukken.

[TIP]
--
In de Rakudo Star bundel zit ook een regel-editor die het uitproberen in de REPL nog gemakkelijker maakt.

Indien je alleen maar Rakudo hebt geinstalleerd, en niet Rakudo Star, dan zijn niet alle handige regel-editor mogelijkheden (zoals pijltje naar onder/boven om eerder ingetypte regels te bekijken, pijltje links/rechts om je invoer te veranderen, en automatisch invullen met TAB).
Denk er dan over om het volgende command uit te voeren om deze functionaliteit te installeren:

* `panda install Linenoise` werkt op Windows, Linux en OSX

* `panda install Readline` als je op Linux werkt en de _Readline_ bibliotheek prefereert
--

=== Bewerkingsprogramma's (Editors)
Aangezien je het grootste deel van je tijd Perl 6 programma's in bestanden aan het opslaan bent, is het handig om een goede editor te hebben die Perl 6 syntax herkent.

Ik gebruik https://atom.io/[Atom] en raadt het gebruik daarvan ook een.  Het is een moderne tekst-editor die standaard uitgeleverd wordt met Perl 6 syntax-markeeerder.
https://atom.io/packages/language-perl6fe[Perl6-fe] is een alternatieve Perl 6 syntax-markeerder voor Atom, afgeleid van het origineel, maar met vele bug-fixes en toevoegingen.

Andere mensen in de gemeenschap gebruiken ook http://www.vim.org/[Vim], https://www.gnu.org/software/emacs/[Emacs] of http://padre.perlide.org/[Padre].

Recent versies van Vim worden standaard uitgeleverd met een syntax-markeerder. Emacs en Padre hebben de installatie van extra bibliotheken nodig.


=== Hello World!
Laten we beginnen met het `hello world` ritueel.

[source,perl6]
say 'hello world';

hetgeen ook geschreven kan worden als:

[source,perl6]
'hello world'.say;

=== Syntax overview
Perl 6 kent weinig beperkingen: over het algemeen kun je zoveel spaties (witregels) gebruiken als je zelf wilt.

Opdrachten bestaan over het algemeen uit een regel code die beeindigd wordt door een punt-komma.
`say "Hallo" if True;`

*Expressies* zijn een speciaal soort opdracht die resulteren in een waarde:
`1+2` geeft `3` terug

Expressies bestaan uit *Termen* en *Operatoren*.

*Termen* zijn:

* *Variabelen*: Een waarde die bekeken en veranderd kan worden.

* *Literals* (Letterlijke waarden): een constante waard zoals een getal of een aantal letters (string).

*Operatoren* worden onderverdeeld in deze typen:

|===

| *Type* | *Uitleg* | *Voorbeeld*

| Prefix | Voor de term. | `++1`

| Infix | Tussen twee termen | `1+2`

| Postfix | Volgt na een term | `1++`

| Circumfix | Staat om een term heen | `(1)`

| Postcircumfix | Achter een term, om een andere term heen  | `Array[1]`

|===

==== Naamgeving
Je moet termen een naam geven op het moment dat je ze definieert.

.Regels:
* Ze moeten beginnen met een alphabetisch karakter of een underscore.

* Ze mogen cijfers bevatten (behalve als eerste karakter).

* Ze mogen een of meer koppeltekens `-` en/of enkele aanhalingstekens `'` bevatten (mits omgeven door alphabetische karakters, dus niet als eerste of laatste karakter).

|===

| *Geldig* | *Niet geldig*

| `var1` | `1var`

| `var-one` | `var-1`

| `var'one` | `var'1`

| `var1_` | `var1'`

| `_var` | `-var`

|===

.Naamgevingsconventies:
* Kameelkast (Camel case): `variableNo1`

* Kebabkast (Kebab case): `variable-no1`

* Slangenkast (Snake case): `variable_no1`

Je mag je termen namen geven zoals je zelf wilt, maar het is een goede gewoonte om vast te houden aan een enkele naamgevingsconventie in een programma.

Het gebruik van betekenisvolle namen zal jouw leven als programmeur gemakkelijker maken (en van anderen die later aan jouw programma moeten werken).

* `var1 = var2 * var3` is syntactisch correct, maar de betekenis is niet duidelijk.
* `maandsalaris = dagloon * gewerkte-dagen` geeft beter aan waar het hierover gaat.

==== Commentaar
Een commentaar is een stuk tekst dat bij uitvoering genegeerd wordt, maar van belang kan zijn voor de lezer van de programma-code.

Er zijn 3 manieren om commentaren in een programma te stoppen:

* Enkele regel;
+
[source,perl6]
# Dit is een regel met commentaar

* Ingebed (embedded):
+
[source,perl6]
say #`(Dit is een ingebed commentaar) "Hello World."

* Meer dan 1 regel
+
[source,perl6]
-----------------------------
=begin comment
Dit is een commentaar over meer dan 1 regel
Commentaar 1
Commentaar 2
=end comment
-----------------------------

==== Aanhalingstekens (Quotes)
Een string wordt gedefinieerd door middel van enkele of dubbele aanhalingstekens.

Gebruik altijd dubbele aanhalingstekens:

* als er een enkel aanhalingsteken in de string voorkomt.

* indien de string een variabele bevat die geinterpoleerd moet worden.

[source,perl6]
-----------------------------------
say 'Hello World';   # Hello World
say "Hello World";   # Hello World
say "Don't";         # Don't
my $name = 'John Doe';
say 'Hello $name';   # Hello $name
say "Hello $name";   # Hello John Doe
-----------------------------------

== Operatoren

=== Algemene operatoren
Onderstaande tabel toont de meest voorkomende operatoren.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Operator | Type | Beschrijving | Voorbeeld | Resultaat

| + | Infix | Optelling | 1 + 2 | 3

| - | Infix | Aftrekking | 3 - 1 | 2

| * | Infix | Vermenigvuldiging | 3 * 2 | 6

| ** | Infix | Machtsverheffen | 3 ** 2 | 9

| / | Infix | Delen | 3 / 2 | 1.5

| div | Infix | Geheel getal deling (rond af) | 3 div 2 | 1

| % | Infix | Modulo | 7 % 4 | 3

.2+| %% .2+| Infix .2+| Deelbaarheid | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Infix | Grootse gemene deler | 6 gcd 9 | 3

| lcm | Infix | Kleinste gemene veelvoud | 6 lcm 9 | 18

| == | Infix | Numeriek gelijk | 9 == 7  | False

| != | Infix | Numeriek ongelijk | 9 != 7  | True

| < | Infix | Numeriek kleiner dan | 9 < 7  | False

| > | Infix | Numeriek groter dan | 9 > 7  | True

| \<= | Infix | Numeriek kleiner dan of gelijk aan | 7 \<= 7  | True

| >= | Infix | Numeriek groter dan of gelijk aan | 9 >= 7  | True

| eq | Infix | String gelijk | "John" eq "John"  | True

| ne | Infix | String ongelijk | "John" ne "Jane"  | True

| = | Infix | Toewijzing | my $var = 7  | Wijst de waarde `7` toe aan de variabele `$var`

.2+| ~ .2+| Infix .2+| Letterreeks aaneenschakelen | 9 ~ 7 | 97

<m| "Hi " ~ "there"  <| Hi there

.2+| x .2+| Infix .2+| Letterreeks herhalen | 13 x 3  | 131313

<| "Hello " x 3  <| Hello Hello Hello

.5+| ~~ .5+| Infix .5+| Slim vergelijken | 2 ~~ 2  | True

<| 2 ~~ Int <| True

<| "Perl 6" ~~ "Perl 6" <| True

<| "Perl 6" ~~ Str <| True

<| "enlightenment" ~~ /light/ <| ｢light｣

.2+| ++ | Prefix | Verhoging | my $var = 2; ++$var;  | Verhoog de variabele met `1` en geef de verhoogde waarde terug: `3`

<m| Postfix <d| Verhoging <m| my $var = 2; $var++;  <| Geef de waarde van de variabele terug (`2`) en verhoog de variabele dan met `1`

.2+|\--| Prefix | Verlaging | my $var = 2; --$var;  | Verlaag de variabele met `1` en geef de verlaagde waarde terug: `1`

<m| Postfix <d| Verlaging <m| my $var = 2; $var--;  <| Geef de waarde van de variabele terug (`2`) en verlaag die dan met `1`

.3+| + .3+| Prefix .3+| Forceer naar de numerieke waarde | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Prefix .3+| Forceer naar de negatieve numerieke waarde | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Prefix .6+| Forceer naar de boolean waarde | ?0 | False

<| ?9.8 <| True

<| ?"Hello" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Prefix | Forceer naar de tegenovergestelde boolean waarde | !4 | False

| .. | Infix | Lijst constructeur |  0..5  | Maak een lijst van 0 t/m 5

| ..^ | Infix | Lijst constructeur |  0..^5  | Maak een lijst van 0 t/m 4

| ^.. | Infix | Lijst constructeur |  0^..5  | Maak een lijst van 1 t/m 5

| \^..^ | Infix | Lijst constructeur |  0\^..^5  | maak een lijst van 1 t/m 4

| ^ | Prefix | Lijst constructeur |  ^5  | Zelfde als 0..^5, maakt een lijst van 0 t/m 4

| ... | Infix | Luie lijst constructeur |  0...9999  | Maak waarden alleen aan indien daar expliciet om gevraagd wordt

.2+| {vbar} .2+| Prefix .2+| Pletten | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

=== Reversi operatoren

Door een `R` te plaatsen direct voor een operator, zorg je ervoor dat de termen omgewisseld worden.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Normale operator | Resultaat | Reversi Operator | Resultaat

| 2 / 3 | 0.666667 | 2 R/ 3 | 1.5

| 2 - 1 | 1 | 2 R- 1 | -1

|===

=== Herleidingsoperatoren

Herleidingsoperatoren werken op lijsten.
Je maakt een herleidingsoperator door vierkante haken om de operator te plaatsen `[]`

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Normal Operator | Resultaat | Herleidingsoperator | Resultaat

| 1 + 2 + 3 + 4 + 5 | 15 | [+] 1,2,3,4,5 | 15

| 1 * 2 * 3 * 4 * 5 | 120 | [*] 1,2,3,4,5 | 120

|===

NOTE: voor een compleet overzicht van operatoren, inclusief hun prioriteit, ga dan naar https://docs.perl6.org/language/operators

== Variabelen
Perl 6 variabelen kunnen worden geclassificeerd in 3 categorieen: Scalars, Arrays en Hashes.

Een *voorteken* (sigil) is een karakter dat als prefix gebruikt wordt om aan te geven in welke categorie een variabele hoort.

* `$` geeft een scalar aan
* `@` geeft een array aan
* `%` geeft een hash aan

=== Scalars
Een scalar kan 1 waarde bevatten.

[source,perl6]
----
#String
my $name = 'John Doe';
say $name;

#Integer
my $age = 99;
say $age;
----

Afhankelijk van het type waarde dat een scalar bevat, kun je daar bepaalde operaties op uitvoeren.

[source,perl6]
.String
----
my $name = 'John Doe';
say $name.uc;
say $name.chars;
say $name.flip;
----

----
JOHN DOE
8
eoD nhoJ
----

NOTE: Bekijk https://docs.perl6.org/type/Str voor de complete lijst van methoden die men op een string kan uitvoeren.

[source,perl6]
.Integer
----
my $age = 17;
say $age.is-prime;
----

----
True
----

NOTE: Bekijk https://docs.perl6.org/type/Int voor de complete lijst van methoden die men op een geheel getal (integer) kan uitvoeren.

[source,perl6]
.Rational Number
----
my $age = 2.3;
say $age.numerator;
say $age.denominator;
say $age.nude;
----

----
23
10
(23 10)
----

NOTE: Bekijk https://docs.perl6.org/type/Rat voor de complete lijst van methoden die men op een rationeel getal kan uitvoeren.

=== Arrays
Arrays bestaan uit een lijst van scalar variabelen.

[source,perl6]
----
my @animals = 'camel','llama','owl';
say @animals;
----

Vele operaties kunnen op arrays uitgevoerd worden, zoals getoond in onderstaand voorbeeld:

TIP: De tilde `~` wordt gebruikt om strings aan elkaar te plakken.

[source,perl6]
.`Script`
----
my @animals = 'kameel','vicuña','lama';
say "De dierentuin heeft " ~ @animals.elems ~ " dieren";
say "De dieren zijn: " ~ @animals;
say "Ik ga een uil adopteren voor de dierentuin";
@animals.push("owl");
say "Nu heeft mijn dierentuin: " ~ @animals;
say "Het eerste dier dat we adopteerden was de " ~ @animals[0];
@animals.pop;
say "Helaas is de uil ontsnapt, dus hebben we nu alleen nog: " ~ @animals;
say "We gaan de dierention sluiten en houden nog maar 1 dier over";
say "We laten de " ~ @animals.splice(1,2) ~ " gaan en houden de " ~ @animals;
----

.`Uitvoer`
----
De dierentuin heeft 3 dieren
De dieren zijn: kameel vicuña lama
Ik ga een uil adopteren voor de dierentuin
Nu heeft mijn dierentuin: kameel vicuña lama uil
Het eerste dier dat we adopteerden was de kameel
Helaas is de uil ontsnapt, dus hebben we nu alleen nog: kameel vicuña lama
We gaan de dierention sluiten en houden nog maar 1 dier over
We laten de vicuña llama gaan en houden de kameel
----

.Uitleg
`.elems` geeft het aantal elementen in een array. +
`.push()` voegt een element toe aan een array. +
We kunnen een specifiek element van een array bekijken door de positie aan te geven `@animals[0]`. +
`.pop` verwijdert het laatste element van het array. +
`.splice(a,b)` verwijdert `b` elementen vanaf positie `a`.

==== Arrays met beperkt aantal elementen
Een gewoon array kun je als volgt specificeren:
[source,perl6]
my @array;

Een gewoon array is niet beperkt wat betreft aantal elementen, het past zichzelf aan (auto-extending). +
Men kan in een gewoon array zoveel waarden opslaan als men wil.

Daarentegen is het ook mogelijk om een array aan te maken met een beperkt aantal elementen.
Dit soort arrays verbieden toegang tot niet-bestaande elementen.

Specificeer het aantal elementen in vierkante haken direct achter de naam van een array om een array met beperkt aantal elementen te specificeren:
[source,perl6]
my @array[3];

Dit array kan hoogstens 3 waarden bevatten, met als indexwaarden 0 t/m 2.

[source,perl6]
----
my @array[3];
@array[0] = "eerste waarde";
@array[1] = "tweede waarde";
@array[2] = "derde waarde";
----

Het is niet mogelijk om een vierde waarde aan dit array toe te voegen:
[source,perl6]
----
my @array[3];
@array[0] = "eerste waarde";
@array[1] = "tweede waarde";
@array[2] = "derde waarde
@array[3] = "vierde waarde";
----

----
Index 3 for dimension 1 out of range (must be 0..2)
----

==== Multidimensionele arrays
De arrays die we tot nu toe gezien hebben, hadden maar 1 dimensie. +
The arrays we saw until now are one-dimensional. +
We kunnen echter ook arrays met meer dan 1 dimensie in Perl 6 specificeren.

[source,perl6]
my @tbl[3;2];

Dit array heeft 2 dimensies.
De eerste dimensie kan maximaal 3 waarden hebben, en de tweede dimensie maximaal 2 waarden.

Zie het als een rooster van 3x2.

[source,perl6]
----
my @tbl[3;2];
@tbl[0;0] = 1;
@tbl[0;1] = "x";
@tbl[1;0] = 2;
@tbl[1;1] = "y";
@tbl[2;0] = 3;
@tbl[2;1] = "z";
say @tbl
----

----
[[1 x] [2 y] [3 z]]
----

.Visuele weergave van het array:
----
[1 x]
[2 y]
[3 z]
----

NOTE: zie https://docs.perl6.org/type/Array voor volledige informatie over arrays.

=== Hashes
[source,perl6]
.Een Hash is een verzameling van naam/waarde paren (key/value pairs)
----
my %hoofdsteden = ('VK','Londen','Duitsland','Berlijn');
say %hoofdsteden;
----

.`Uitvoer`
----
{Duitsland => Berlijn, VK => Londen}
----

[source,perl6]
.Een andere manier om een hash te vullen:
----
my %hoofdsteden = (UK => 'London', Germany => 'Berlin');
say %hoofdsteden;
----

.`Uitvoer`
----
{Duitsland => Berlijn, VK => Londen}
----

Dit zijn een aantal van de methoden die men op een hash kan uitvoeren:
[source,perl6]
.`Script`
----
my %hoofdsteden = (VK => 'Londen', Duitsland => 'Berlijn');
%hoofdsteden.push: (Frankrijk => 'Parijs');
say %hoofdsteden.kv;
say %hoofdsteden.keys;
say %hoofdsteden.values;
say "De hoofdstad van Frankrijk is: " ~ %hoofdsteden<Frankrijk>;
----

.`Uitvoer`
----
(Frankrijk Parijs Duitsland Berlijn VK Londen)
(Frankrijk Duitsland VK)
(Parijs Berlijn Londen)
De hoofdstad van Frankrijk is: Parijs
----

.Uitleg
`.push: (naam => 'Waarde')` voegt een nieuw naam/waarde paar toe. +
`.kv` geeft een lijst met alle namen en waarden terug. +
`.keys` geeft een lijst met alle namen terug. +
`.values` geeft een lijst met alle waarden terug. +
De waarde behorende bij een gegeven naam kun je opvragen door die naam te specificeren `%hash<naam>`

NOTE: Zie https://docs.perl6.org/type/Hash voor alle informatie over hashes.

=== Types
In de voorafgaande voorbeelden hebben we niet het type van de waarde aangegeven die in een variabele opgeslagen kan worden.

TIP: `.WHAT` geeft het type van de waarde in een variabele terug.

[source,perl6]
----
my $var = 'Tekst';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
----

Zoals je kunt zien in bovenstaand voorbeeld, was het type van de waarde in `$var` eerst (Str) en daarna (Int).

Deze stijl van programmeren wordt dynamische typering (dynamic typing) genoemd.  Dynamisch in de betekenis dat de variable waarden mag bevatten van elk (Any) type.

Probeer nu onderstaand voorbeeld uit te voeren: +
Merk op dat we `Int` voor de naam van de variabele hebben geplaatst.

[source,perl6]
----
my Int $var = 'Tekst';
say $var;
say $var.WHAT;
----

Het zal fout gaan en terug komen met dit foutbericht: `Type check failed in assignment to $var; expected Int but got Str`

Wat hier gebeurde is dat we van te voren hadden aangegeven dat de variabele alleen maar (Int) zou accepteren.
Toen we probeerden om er een string (Str) aan toe te wijzen, was dat niet mogelijk en ging het fout.

Deze stijl van programmeren wordt "statische typering" (static typing) genoemd.  Statisch omdat het type van variabelen wordt gedefinieerd voordat er aan wordt toegewezen, en deze later niet kan worden veranderd.

Perl 6 wordt aangeduid met "graduele typering": het laat namelijk zowel *statische* als *dynamische* typering toe.

.Arrays en hashes kunnen ook statisch getypeerd worden:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @veeltalig = "Hello","Salut","Hallo","您好","안녕하세요","こんにちは";
say @veeltalig;
say @veeltalig.WHAT;

my Str %hoofdsteden = (VK => 'Londen', Duitsland => 'Berlijn');
say %hoofdsteden;
say %hoofdsteden.WHAT;

my Int %landennummers = (VK => 44, Duitsland => 49);
say %landennummers;
say %landennummers.WHAT;
----

.Hieronder vind je een lijst van meest voorkomende typen:
Je zult hoogstwaarschijnlijk de eerste twee nooit gebruiken, maar we laten ze hier zien om je te laten weten dat ze bestaan.

[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Type* | *Beschrijving* | *Voorbeeld* | *Resultaat*

| Mu | De ultieme basis van de Perl 6 typen hierarchie | |

| Any | Het basis type voor nieuwe klassen en de meeste standaard klassen | |

| Cool | Waarden die zowel als string of als number kunnen worden beschouwd | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Een string: reeks van karakters | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Integer (elke gewenste precisie) | 7 + 7 | 14

| Rat | Rationeel nummer (beperkte precisie) | 0.1 + 0.2 | 0.3

| Bool | Boolean | !True | False

|===

=== Introspectie

Met introspectie bedoelen we het process waarmee we informatie over de eigenschappen van een object kunnen bekijken, zoals het type. +
In een van de vorige voorbeelden gebruikten we `.WHAT` om het type van een variabele te achterhalen.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hello";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

Het type van een variabele waarin een waarde is opgeslagen, is gecorreleerd aan die waarde. +
Het type van een lege variabele die gespecificeerd is met een type, is het type waarmee het werd gespecificeerd. +
Het type van een lege variabele die niet is gespecificeerd met een type, is `(Any)` +
Om de waarde uit een variabele te verwijderen, kun je de waarde `Nil` toewijzen.

=== Bereik (scoping)
Voordat men een variabele voor de eerste keer kan gebruiken, moet deze worden gespecificeerd.

Dit kan op diverse manieren in Perl 6, `my` is wat we tot nu toe in de bovenstaande voorbeelden hebben gebruikt.

[source,perl6]
my $var=1;

Met `my` geeft men de variabele een *statisch* bereik (ook wel *lexicaal bereik genoemd).
In andere woorden, de variabele zal alleen maar toegankelijk zijn in het gebied (scope) waarin het was gespecificeerd.

Zo'n gebied (scope) wordt in Perl 6 begrensd door `{ }`.
Een variabele zal alleen toegankelijk zijn in een Perl 6 script als er geen gebiedsbegrenzing gevonden wordt.

[source,perl6]
----
{
  my Str $var = 'Tekst';
  say $var; # is toegankelijk
}
say $var; #is niet toegankelijk, geeft een foutmelding
----

Aangzien zo'n variabele alleen toegankelijk is in het gebied waarin het was gedefinieerd, kan men dezelfde naam voor een variabele gebruiken in een ander gebied.

[source,perl6]
----
{
  my Str $var = 'Tekst';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Toewijzing vs. verbinden
We hebben in de vorige voorbeelden gezien hoe we waarden aan variabelen kunnen *toewijzen*. +
*Toewijzing* wordt gedaan met de `=` operator.

[source,perl6]
----
my Int $var = 123;
say $var;
----

We kunnen de waarde van een variabele veranderen:

[source,perl6]
.Toewijzing
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Uitvoer`
----
123
999
----

Daarentegen kunnen we de waarde van een variabele niet veranderen als deze is *verbonden* met een variabele. +
*Verbinding* wordt gedaan met de `:=` operator.

[source,perl6]
.Verbinden
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Output`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Variabelen kunnen ook verbonden worden met andere variabelen:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Uitvoer`
----
7
8
----

Het verbinden van variabelen werkt twee kanten op, zoals je al gezien hebt. +
`$a := $b` en `$b := $a` hebben hetzelfde effect.

NOTE: Zie https://docs.perl6.org/language/variables voor meer informatie over variabelen.

== Functies en mutators

Het is belangrijk om verschil te maken tussen functies en mutators. +
Functies veranderen de toestand van een object waarop ze worden uitgevoerd *niet*. +
Mutators veranderen de toestand van een object *wel*.

[source,perl6,linenums]
.`Script`
----
my @nummers = [7,2,4,9,11,3];

@nummers.push(99);
say @nummers;      #1

say @nummers.sort; #2
say @nummers;      #3

@nummers.=sort;
say @nummers;      #4
----

.`Output`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Uitleg
`.push` is een mutator, het verandert de toestand van het array (#1)

`.sort` is een functie, het geeft het gesorteerde array terug als een lijst, maar verandert de toestand van het array zelf niet.

* (#2) laat zien dat een gesorteerde lijst is teruggegeven.

* (#3) laat zien dat het array zelf onveranderd is.

Men kan een functie als een mutator laten optreden door `.=` in plaats van `.` te gebruiken (#4) (regel 9 van het script)

== Lussen en condities
Perl 6 heeft een veelheid aan conditionele- en lusconstructies.

=== if
De code in het bereik van de conditionele constructie  wordt alleen maar uitgevoerd *indien* de conditie waar (`True`) is.

[source,perl6]
----
my $leeftijd = 19;

if $leeftijd > 18 {
    say 'Welkom'
}
----

In Perl 6 kunnen we de volgorde van de code en de conditie omkeren. +
Maar zelfs als de volgorde is omgekeerd, zal de conditie altijd eerst worden uitgevoerd.

[source,perl6]
----
my $leeftijd = 19;

say 'Welkom' if $leeftijd > 18;
----

We kunnen alternatieve bereiken voor uitvoering aangeven voor het geval dat de conditie niet waar is:

* `else`
* `elsif`

[source,perl6]
----
#voer deze code uit voor verschillende waarden van de variabele
my $aantal-stoelen = 9;

if $aantal-stoelen <= 5 {
    say 'Ik ben een personenauto'
} elsif $aantal-stoelen <= 7 {
    say 'Ik ben een busje'
} else {
    say 'Ik ben een bus'
}
----

=== unless
De tegenovergestelde, ontkennende versie van een if command is `unless` (tenzij).

Deze code:

[source,perl6]
----
my $schone-schoenen = False;

if not $schone-schoenen {
    say 'Maak je schoenen schoon'
}
----
Kan geschreven worden als:

[source,perl6]
----
my $schone-schoenen = False;

unless $schone-schoenen {
    say 'Maak je schoenen schoon'
}
----

Ontkenning (negation) wordt in Perl 6 gedaan met `!` of `not`.

`unless (conditie)` kan worden gebruikt in plaats van `if not (conditie)`.

`unless` kan geen `else` bereik hebben.

=== with

`with` gedraagt zich als een `if` commando, maar kijkt of de variabele een waarde heeft.

[source,perl6]
----
my Int $var=1;

with $var {
    say 'Hallo'
}
----

Als je deze code uitvoert zonder dat je een waarde aan de variabele hebt toegekend, dan zou je geen uitvoer moeten zien.

[source,perl6]
----
my Int $var;

with $var {
    say 'Hallo'
}
----

`without` is de ontkennende versie van `with`.  Net als `unless` van `if`.

Indien de eerste `with` niet waar is, dan kan men een alternatief bereik aangeven met `orwith`. +
Je kunt `with` en `orwith` zien als een soort `if` en `elsif`.

=== for

Met het `for` commando kun je over een aantal waarden repeteren.

[source,perl6]
----
my @array = [1,2,3];

for @array -> $array-item {
    say $array-item * 100
}
----

Merk op dat we een lusvariabele `$array-item` aanmaken om de operatie `*100` op elk element van het array uit te kunnen voeren.

=== given

`given` is het Perl 6 equivalent van het `switch` commando in andere programmeertalen.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Minder dan of gelijk aan 50'}
    when Int { say "is een Int" }
    when 42  { say 42 }
    default  { say "huh?" }
}
----

Het testen van condities stops zodra een conditie van een `when` waar is geweest.

Met `proceed` kun je in Perl 6 aangeven dat je door wilt gaan met testen van condities nadat een conditie waar was.
[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Minder dan of gelijk aan 50';proceed}
    when Int { say "is een Int";proceed}
    when 42  { say 42 }
    default  { say "huh?" }
}
----

=== loop

`loop` is een andere manier om een `for` lus aan te geven.

In feite is `loop` precies zoals `for` lussen geschreven worden in de familie C-programmeertalen.

Perl 6 hoort bij de familie C-programmeertalen.

[source,perl6]
----
loop (my $i = 0; $i < 5; $i++) {
    say "Het huidige nummer is $i"
}
----

NOTE: Zie https://docs.perl6.org/language/control voor meer informatie over conditionele- en lusconstructies.

== I/O
De twee meest voorkomende manieren van _Invoer/Uitvoer_ zijn _Terminal_ en _Bestanden_.

=== Basic I/O using the Terminal

==== say
`say` schrijft naar de standaard uitvoer.  Het voegt een regeleinde (newline) toe aan het einde.  In andere woorden, de volgende code:

[source,perl6]
----
say 'Hallo mevrouw.';
say 'Hallo meneer.';
----
zullen op 2 aparte lijnen worden getoond.

==== print
Aan de andere kant doet `print` precies hetzelfde, maar het voegt geen regeleinde toe.

Probeer eens om de `say` door een `print` te vervangen en vergelijk de resultaten.

==== get
Men kan `get` gebruiken om invoer van de terminal te krijgen.

[source,perl6]
----
my $naam;

say "Hoi, hoe heet je?";
$name = get;

say "Welkom bij Perl 6, beste $naam";
----

Indien je bovenstaande code uitvoert zal de terminal wachten tot je je naam intypt en op [Enter] drukt.
Vervolgens zal het je begroeten.

==== prompt
`prompt` is een combinatie van `print` en `get`.

Het bovenstaande voorbeeld kan ook worden geschreven als:

[source,perl6]
----
my $naam = prompt "Hoi, hoe heet je? ";

say "Welkom bij Perl 6, beste $naam";
----

=== Uitvoeren van externe commando's
Deze twee subroutines kunnen worden gebruikt om externe commando's uit te voeren:

* `run` voert een extern commando direct uit.

* `shell` voert een extern commando uit alsof je het hebt ingetypt op een commando regel (via een z.g. "shell").  Het hangt af van de systeem software die je gebruikt.
Alle meta-karakters worden geinterpreteerd door de shell, inclusief z.g. "pipes", "redirects" en specificaties van environment variabelen.

[source,perl6]
.Voer dit uit als je met Linux/OSX werkt
----
my $naam = 'Neo';
run 'echo', "hallo $naam";
shell "ls";
----

[source,perl6]
.Voer dit uit als je met Windows werkt
----
shell "dir";
----
`echo` en `ls` zijn veel voorkomende commando's op Linux/OSX: +
`echo` drukt de parameters af (het equivalent van `print` in Perl 6) +
`ls` laat alle bestanden en directories zien in de huidige directory

`dir` is het equivalent van `ls` bij Windows.


=== File I/O
==== slurp
Men kan `slurp` gebruiken om een geheel bestand in te lezen.

Maak een tekstbestand aan met de volgende inhoud:

.scores.txt
----
John 9
Johnnie 7
Jane 8
Joanna 7
----
[source,perl6]
----
my $data = slurp "scores.txt";
say $data;
----

==== spurt
Men kan `spurt` gebruiken om data naar een bestand te schrijven.

[source,perl6]
----
my $nieuw = "Nieuwe scores:
Paul 10
Paulie 9
Paulo 11";

spurt "nieuwescores.txt", $nieuw;
----

Nadat je de bovenstaande code hebt uitgevoerd, bestaat er een bestand _nieuwescores.txt_ .  Dat zal dan de nieuwe scores bevatten.

=== Werken met bestanden en directories
Perl 6 kan de inhoud van een directory ook direct tonen zonder dat er externe commando's voor hoeven te worden uitgevoerd, net zoals in een van de vorige voorbeelden.

[source,perl6]
----
say dir;              #Laat bestanden/directories uit de huidige directory zien
say dir "/Documents"; #Laat bestanden/directories zien van de gegeven directory
----

Tevens kun je ook nieuwe directories aanmaken en verwijderen.

[source,perl6]
----
mkdir "nieuwdir";
rmdir "nieuwdir";
----

`mkdir` maakt een nieuwe directory aan. +
`rmdir` verwijdert een lege directory.  Returned een foutmelding indien niet leeg.

Je kunt ook kijken of een specifieke naam bestaat, en of het een bestand of een directory is:

Maak in de directory waar je dit script gaat uitvoeren een lege directory `dir123` en een leeg bestand genaamd `script123.pl6`

[source,perl6]
----
say "script123.pl6".IO.e;
say "dir123".IO.e;

say "script123.pl6".IO.d;
say "dir123".IO.d;

say "script123.pl6".IO.f;
say "dir123".IO.f;
----

`IO.e` geeft terug of de naam bestaat. +
`IO.f` geeft terug of het een bestand is. +
`IO.d` geeft terug of het een directory is.

WARNING: Gebruikers van Windows kunnen zowel de `/` als de `\\` gebruiken om directories aan te maken +
`C:\\rakudo\\bin` +
`C:/rakudo/bin` +

NOTE: Zie https://docs.perl6.org/type/IO voor meer informatie over invoer en uitvoer.

== Subroutines
=== Definition
*Subroutines* (also called *subs* or *functions*) are a means of packaging a set of functionality. +

A subroutine definition begins with the keyword `sub`. After their definition, they can be called by their handle. +
Check out the below example:

[source,perl6]
----
sub alien-greeting {
  say "Hello earthlings";
}

alien-greeting;
----

The previous example showcased a subroutine that  doesn't require any input.

=== Signature
Many subroutines would require some input in order to work. That input is provided by *arguments*.
The number and type of arguments that this subroutine accepts is called its *signature*.

The below subroutine accepts a string argument.

[source,perl6]
----
sub say-hello (Str $name) {
    say "Hello " ~ $name ~ "!!!!"
}
say-hello "Paul";
say-hello "Paula";
----

=== Multiple dispatch
It is possible to define multiple subroutines having the same name but different signatures.
When the subroutine is called, the runtime environment will decide which version to use depending on the number and type of the supplied arguments.
This type of subroutines is defined the same way as normal subs with the exception of swapping the `sub` keyword with `multi`.

[source,perl6]
----
multi greet($name) {
    say "Good morning $name";
}
multi greet($name, $title) {
    say "Good morning $title $name";
}

greet "Johnnie";
greet "Laura","Mrs.";
----

=== Default and Optional Arguments
If a subroutine is defined to accept an argument, and we call it without providing it with the required argument, it will fail.

Alternatively Perl 6 provides us the ability to define subroutines with:

* Optional Arguments
* Default Arguments

Optional arguments are defined by appending `?` to the argument name.

[source,perl6]
----
sub say-hello($name?) {
  with $name { say "Hello " ~ $name }
  else { say "Hello Human" }
}
say-hello;
say-hello("Laura");
----

If the user doesn't supply an argument, it can default to a specific value. +
This is done by assigning a value to the argument within the subroutine definition.

[source,perl6]
----
sub say-hello($name="Matt") {
  say "Hello " ~ $name;
}
say-hello;
say-hello("Laura");
----

=== Returning values
All the subroutines we saw so far *do something*, they display some text on the terminal.

While this is perfectly normal, sometimes we do want a subroutine to *return* some kind of value that we can reuse later in the flow of our program.

Under normal circumstances, the last line of code of a subroutine is considered to be the return value.
[source,perl6]
.Implicit return
----
sub squared ($x) {
  $x ** 2;
}
say "7 squared is equal to " ~ squared(7);
----

Once our code gets bigger, it might be a good idea to _explicitly_ specify what we do want to return.
This can be done using the `return` keyword.
[source,perl6]
.Explicit return
----
sub squared ($x) {
  return $x ** 2;
}
say "7 squared is equal to " ~ squared(7);
----
==== Restricting return values
In one of the previous examples, we saw how we can restrict the accepted argument to be of a certain type.
The same can be done with return values.

To restrict the return value to a certain type, we either use the `returns` trait or the arrow notation `-\->` in the signature.

[source,perl6]
.Using the returns trait
----
sub squared ($x) returns Int {
  return $x ** 2;
}
say "1.2 squared is equal to " ~ squared(1.2);
----

[source,perl6]
.Using the arrow
----
sub squared ($x --> Int) {
  return $x ** 2;
}
say "1.2 squared is equal to " ~ squared(1.2);
----
If we fail to provide a return value that matches the type constraint, an error will be thrown.

----
Type check failed for return value; expected Int but got Rat (1.44)
----

[TIP]
====
Not only can type constraints control the type of the return value; they can also control its definedness.

In the previous examples, we specified that the return value should be an `Int`, irrespective of its definedness.
Alternatively we could have specified that the returned `Int` should be strictly defined or undefined using the following signatures: +
`--> Int:D` and `--> Int:U`

That being said, it is good practice to use those type constraints. +
Below is the modified version of the previous example that uses `:D` to force the returned  `Int` to be defined.

[source,perl6]
----
sub squared ($x --> Int:D) {
  return $x ** 2;
}
say "1.2 squared is equal to " ~ squared(1.2);
----
====

NOTE: For more info on subroutines and functions, see https://docs.perl6.org/language/functions

== Functional Programming
In this chapter we will take a look at some of the functionality that facilitates Functional Programming.

=== Functions are first-class citizens
Functions/subroutines are first-class citizens:

* They can be passed as an argument

* They can be returned from another function

* They can be assigned to a variable

A great example to demonstrate this concept is the `map` function. +
`map` is a *higher order function*, it accepts another function as an argument.

[source,perl6]
.Script
----
my @array = <1 2 3 4 5>;
sub squared($x) {
  $x ** 2
}
say map(&squared,@array);
----

.Output
----
(1 4 9 16 25)
----

.Explanation
We defined a subroutine called `squared`, it will take to the power of two any number provided as argument. +
Next, we used `map`, a higher order function and gave it two arguments, a subroutine and an array. +
The result is a list of all squared elements of the array.

Notice that when passing a subroutine as an argument, we need to prepend `&` to its name.

=== Closures
All code objects in Perl 6 are closures, which means they can reference lexical variables from an outer scope.

=== Anonymous functions
An *anonymous function* is also called a *lambda*. +
An anonymous function is not bound to an identifier (it has no name).

Let's rewrite the `map` example using an anonymous function
[source,perl6]
----
my @array = <1 2 3 4 5>;
say map(-> $x {$x ** 2},@array);
----
Notice that instead of declaring the subroutine and passing it as an argument to `map`, we defined it directly within. +
The anonymous subroutine `\-> $x {$x ** 2}` has no handle and cannot be called.

In Perl 6 parlance we call this notation  a *pointy block*

[source,perl6]
.A pointy block may also be used to assign functions to variables:
----
my $squared = -> $x {
  $x ** 2
}
say $squared(9);
----

=== Chaining
In Perl 6, methods can be chained, you no longer have to pass the result of a method to another one as an argument.

Lets consider that you are provided with an array of values.
You are asked to return the unique values of this array, sorted from biggest to smallest.

You might try to solve the problem by writing something close to this:
[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = reverse(sort(unique(@array)));
say @final-array;
----
First we call the `unique` function on `@array` then we pass the result as an argument to `sort` and then we pass the result of sorting to `reverse`.

In contrast with the above example, chaining methods is allowed in Perl 6. +
The above example can be written as following, taking advantage of *method chaining*:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = @array.unique.sort.reverse;
say @final-array;
----

You can already see that chaining methods is _easier on the eye_.

=== Feed Operator
The *feed operator*, called _pipe_ in some functional programming languages, yields yet a better visualization of method chaining.
[source,perl6]
.Forward Feed
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
@array ==> unique()
       ==> sort()
       ==> reverse()
       ==> my @final-array;
say @final-array;
----

.Explanation
----
Start with `@array` then return a list of unique elements
                    then sort it
                    then reverse it
                    then store the result in @final-array
----
As you can see the flow of the method calls is top-down.


[source,perl6]
.Backward Feed
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array-v2 <== reverse()
                   <== sort()
                   <== unique()
                   <== @array;
say @final-array-v2;
----

.Explanation
The backward feed is like the forward feed, but written in reverse. +
The flow of the method calls is bottom-up.

=== Hyper operator
The *hyper operator* `>>.` will call a method on all elements of a list and return a list of all results.
[source,perl6]
----
my @array = <0 1 2 3 4 5 6 7 8 9 10>;
sub is-even($var) { $var %% 2 };

say @array>>.is-prime;
say @array>>.&is-even;
----

Using the hyper operator we can call methods already defined in Perl 6, e.g. `is-prime` that tells us if a number is prime or not. +
In addition we can define new subroutines and call them using the hyper operator. In this case we have to prepend `&` to the name of the method. E.g. `&is-even`

This is very practical as it relieves us from writing a `for` loop to iterate over each value.

=== Junctions
A *junction* is a logical superposition of values.

In the below example `1|2|3` is a junction.
[source,perl6]
----
my $var = 2;
if $var == 1|2|3 {
  say "The variable is 1 or 2 or 3"
}
----
The use of junctions usually triggers *autothreading*;
the operation is carried out for each junction element, and all the results are combined into a new junction and returned.

=== Lazy Lists
A *lazy list* is a list that is lazily evaluated. +
Lazy evaluation delays the evaluation of an expression until required, and avoids repeating evaluations by storing results in a lookup table.

The benefits include:

* Performance increase by avoiding needless calculations

* The ability to construct potentially infinite data structures

* The ability to define control flow

To build a lazy list we use the infix operator `...` +
A lazy list has *initial element(s)*, a *generator* and an *endpoint*.

[source,perl6]
.Simple lazy list
----
my $lazylist = (1 ... 10);
say $lazylist;
----
The initial element is 1 and the endpoint is 10. No generator was defined so the default generator is the successor (+1) +
In other words this lazy list may return (if requested) the following elements (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

[source,perl6]
.Infinite lazy list
----
my $lazylist = (1 ... Inf);
say $lazylist;
----
This list may return (if requested) any integer between 1 and infinity, in other words any integer number.

[source,perl6]
.Lazy list built using a deduced generator
----
my $lazylist = (0,2 ... 10);
say $lazylist;
----
The initial elements are 0 and 2 and the endpoint is 10.
No generator was defined, but using the initial elements, Perl 6 will deduce that the generator is (+2) +
This lazy list may return (if requested) the following elements (0, 2, 4, 6, 8, 10)

[source,perl6]
.Lazy list built using a defined generator
----
my $lazylist = (0, { $_ + 3 } ... 12);
say $lazylist;
----
In this example, we defined explicitly a generator enclosed in `{ }` +
This lazy list may return (if requested) the following elements (0, 3, 6, 9, 12)

[WARNING]
====
When using an explicit generator, the endpoint must be one of the values that the generator can return. +
If we reproduce the above example with the endpoint being 10 instead of 12, it will not stop.
The generator _jumps over_ the endpoint.

Alternatively you can replace `0 ... 10` with `0 ...^ * > 10` +
You can read it as: From 0 until the first value greater than 10 (excluding it)
[source,perl6]
.This will not stop the generator
----
my $lazylist = (0, { $_ + 3 } ... 10);
say $lazylist;
----

[source,perl6]
.This will stop the generator
----
my $lazylist = (0, { $_ + 3 } ...^ * > 10);
say $lazylist;
----
====

== Classes & Objects
In the previous chapter, we learned how Perl 6 facilitates Functional Programming. +
In this chapter we will take a look at Object Oriented programming in Perl 6.

=== Inleiding

_Object Oriented_ programming is one of the widely used paradigms nowadays. +
An *object* is a set of variables and subroutines bundled together. +
The variables are called *attributes* and the subroutines are called *methods*. +
Attributes define the *state* and methods define the *behavior* of an object.

A *class* defines the structure of a set of *objects*. +

In order to understand the relationship consider the below example:

|===

| There are 4 people present in a room | *objects* => 4 people

| These 4 people are humans | *class* => Human

| They have different names, age, sex and nationality | *attributes* => name, age, sex, nationality

|===

In _object oriented_ parlance, we say that objects are *instances* of a class.

Consider the below script:
[source,perl6]
----
class Human {
  has $name;
  has $age;
  has $sex;
  has $nationality;
}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
say $john;
----
The `class` keyword is used to define a class. +
The `has` keyword is used to define attributes of a class. +
The `.new()` method is called a *constructor*. It creates the object as an instance of the class it has been called on.

In the above script, a new variable `$john` holds a reference to a new instance of "Human" defined by `Human.new()`. +
The arguments passed to the `.new()` method are used to set the attributes of the underlying object.

A class can be given _lexical scope_ using `my`:
[source,perl6]
----
my class Human {

}
----

=== Encapsulation
Encapsulation  is an object oriented concept that bundles a set of data and methods together. +
The data (attributes) within an object should be *private*, in other words, accessible only from within the object. +
In order to access the attributes from outside the object we use methods that we call *accessors*.

The below two scripts have the same result.

.Direct access to the variable:
[source,perl6]
----
my $var = 7;
say $var;
----

.Encapsulation:
[source,perl6]
----
my $var = 7;
sub sayvar {
  $var;
}
say sayvar;
----
The method `sayvar` is an accessor. It let us access the value of the variable without getting direct access to it.

Encapsulation is facilitated in Perl 6 with the use of *twigils*. +
Twigils are secondary _sigils_. They come between the sigil and the attribute name. +
Two twigils are used in classes:

* `!` is used to explicitly declare that the attribute is private.
* `.` is used to automatically generate an accessor for the attribute.

By default, all attributes are private but it is a good habit to always use the `!` twigil.

In line with what we said we should rewrite the above class as following:
[source,perl6]
----
class Human {
  has $!name;
  has $!age;
  has $!sex;
  has $!nationality;
}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
say $john;
----
Append to the script the following statement: `say $john.age;` +
It will return the following error: `Method 'age' not found for invocant of class 'Human'` +
The reason being that `$!age` is private and can only be used within the object.
Trying to access it outside the object will return an error.

Now replace `has $!age` with `has $.age` and see what will be the result of `say $john.age;`

=== Named vs. Positional Arguments
In Perl 6, all classes inherit a default `.new()` constructor. +
It can be used to create objects by providing it with arguments. +
The default constructor can only be provided with *named arguments*. +
If you consider the above example, you'll remark that all the arguments supplied to `.new()` are defined by name:

* name => 'John'

* age => 23


What if i do not want to supply the name of each attribute each time i want to create a new object? +
Then I need to create another constructor that accepts *positional arguments*.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  has $.sex;
  has $.nationality;
  #new constructor that overrides the default one.
  method new ($name,$age,$sex,$nationality) {
    self.bless(:$name,:$age,:$sex,:$nationality);
  }
}

my $john = Human.new('John',23,'M','American');
say $john;
----

=== Methods

==== Inleiding
Methods are the _subroutines_ of an object. +
Like subroutines, they are a means of packaging a set of functionality, they accept *arguments*, have a *signature* and can be defined as *multi*.

Methods are defined using the `method` keyword. +
In normal circumstances, methods are required to perform some sort of action on the objects' attributes.
This enforces the concept of encapsulation. Object attributes can only be manipulated from within the object using methods.
The outside world, can only interact with the object methods, and has no access to its attributes.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  has $.sex;
  has $.nationality;
  has $.eligible;
  method assess-eligibility {
      if self.age < 21 {
        $!eligible = 'No'
      } else {
        $!eligible = 'Yes'
      }
  }

}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
$john.assess-eligibility;
say $john.eligible;
----

Once methods are defined within a class, they can be called on an object using the _dot notation_: +
_object_ *.* _method_ or as in the above example: `$john.assess-eligibility`

Within the definition of a method, if we need to reference the object itself to call another method we use the `self` keyword. +

Within the definition of a method, if we need to reference an attribute we use `!` even if it was defined with `.` +
The rationale being that what the `.` twigil does is declare an attribute with `!` and automate the creation of an accessor.

In the above example `if self.age < 21` and `if $!age < 21` would have the same effect, although they are technically different:

* `self.age` calls the `.age` method (accessor) +
Can be written alternatively as `$.age`
* `$!age` is a direct call to the variable

==== Private methods
Normal methods can be called on objects from outside the class.

*Private methods* are methods that can only be called from within the class. +
A possible use case would be a method that calls another one for specific action.
The method that interfaces with the outside world is public while the one referenced should stay private.
We do not want users to call it directly, so we declare it as private.

The declaration of a private method requires the use of the `!` twigil before its name. +
Private methods are called with `!` instead of `.`

[source,perl6]
----
method !iamprivate {
  #code goes in here
}

method iampublic {
  self!iamprivate;
  #do additional things
}
----

=== Class Attributes

*Class attributes* are attributes that belong to the class itself and not to its objects. +
They can be initialized during definition. +
Class attributes are declared using `my` instead of `has`. +
They are called on the class itself instead of its objects.

[source,perl6]
----
class Human {
  has $.name;
  my $.counter = 0;
  method new($name) {
    Human.counter++;
    self.bless(:$name);
  }
}
my $a = Human.new('a');
my $b = Human.new('b');

say Human.counter;
----

=== Access Type
Until now all the examples that we've seen, used accessors to get information from the objects' attributes.

What if we need to modify the value of an attribute? +
We need to label it as _read/write_ using the following keywords `is rw`
[source,perl6]
----
class Human {
  has $.name;
  has $.age is rw;
}
my $john = Human.new(name => 'John', age => 21);
say $john.age;

$john.age = 23;
say $john.age;
----
By default, all attributes are declared as _read only_ but you can explicitly do it using `is readonly`

=== Inheritance
==== Inleiding
*Inheritance* is another concept of object oriented programming.

When defining classes, soon enough we will realize that some attributes/methods are common to many classes. +
Should we duplicate code? +
NO! We should use *inheritance*

Let's consider we want to define two classes, a class for Human beings and a class for Employees. +
Human beings have 2 attributes: name and age. +
Employees have 4 attributes: name, age, company and salary

One would be tempted to define the classes as follow:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee {
  has $.name;
  has $.age;
  has $.company;
  has $.salary;
}
----
While technically correct the above piece of code is considered conceptually poor.

A better way to write it would be as follow:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee is Human {
  has $.company;
  has $.salary;
}
----
The `is` keyword defines inheritance. +
In object oriented parlance we say Employee is a *child* of Human, and Human is a *parent* of Employee.

All child classes inherit the attributes and methods of the parent class, so there is no need to redefine them.

==== Overriding
Classes inherit all attributes and methods from their parent classes. +
There are cases where we need the method in the child class to behave differently than the one inherited. +
To achieve this, we redefine the method in the child class. +
This concept is called *overriding*.

In the below example, the method `introduce-yourself` is inherited by the Employee class.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
}

my $john = Human.new(name =>'John', age => 23,);
my $jane = Employee.new(name =>'Jane', age => 25, company => 'Acme', salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----
Overriding works as follow:

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
  method introduce-yourself {
    say 'Hi i am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }

}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----

Depending of which class the object is, the right method will be called.

==== Submethods
*Submethods* are a type of method that are not inherited by child classes. +
They are only accessible from the class they were declared in. +
They are defined using the `submethod` keyword.

=== Multiple Inheritance
Multiple inheritance is allowed in Perl 6. A class can inherit from multiple other classes.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
----

.Explanation
The `combo-chart` class should be able to hold two series, one for the actual values plotted on bars,
and another for forecast values plotted on a line. +
This is why we defined it as a child of `line-chart` and `bar-chart`. +
You should have noticed that calling the method `plot` on the `combo-chart` didn't yield the required result.
Only one series was plotted. +
Why did this happen? +
`combo-chart` inherits from `line-chart` and `bar-chart`, and both of them have a method called `plot`.
When we call that method on `combo-chart` Perl 6 internals will try to resolve the conflict by calling one of the inherited methods.

.Correction
In order to behave correctly, we should have overridden the method `plot` in the `combo-chart`.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
[9 8 10 7 6 9]
----

=== Roles
*Roles* are somehow similar to classes in the sense that they are a collection of attributes and methods.

Roles are declared with the keyword `role` and classes that wish to implement the role can do so using the `does` keyword.

.Lets rewrite the multiple inheritance example using roles:
[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

Run the above script and you will see that results are the same.

By now you're asking yourself; if roles behave like classes what's their use? +
To answer your question modify the first script used to showcase multiple inheritance,
the one where we _forgot_ to override the `plot` method.

[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
----

.Explanation
If multiple roles are applied to the same class, and a conflict arises, a compile-time error will be thrown. +
This is a much safer approach than multiple inheritance where conflicts are not considered errors and are simply resolved at runtime.

Roles will warn you that there's a conflict.

=== Introspection
*Introspection* is the process of getting information about an object properties like its type, or its attributes or its methods.

[source,perl6]
----
class Human {
  has Str $.name;
  has Int $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has Str $.company;
  has Int $.salary;
  method introduce-yourself {
    say 'Hi i am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }
}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

say $john.WHAT;
say $jane.WHAT;
say $john.^attributes;
say $jane.^attributes;
say $john.^methods;
say $jane.^methods;
say $jane.^parents;
if $jane ~~ Human {say 'Jane is a Human'};
----
Introspection is facilitated by:

* `.WHAT` returns the class from which the object has been created.

* `.^attributes` returns a list containing all attributes of the objects.

* `.^methods` returns all methods that can be called on the object.

* `.^parents` returns all parent classes of the class the object belongs.

* `~~` is called the smart-match operator.
It evaluates to _True_ if the object is created from the class it is being compared against or any of its inheritances.

[NOTE]
--
For more info on Object Oriented Programming in Perl 6, see:

* https://docs.perl6.org/language/classtut
* https://docs.perl6.org/language/objects
--
== Exception Handling

=== Catching Exceptions
*Exceptions* are a special behavior that happens at runtime when something goes wrong. +
We say that exceptions are _thrown_.

Consider the below script that runs correctly:

[source,perl6]
----
my Str $name;
$name = "Joanna";
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Hello Joanna
How are you doing today?
----

Now consider this script that throws an exception:

[source,perl6]
----
my Str $name;
$name = 123;
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Type check failed in assignment to $name; expected Str but got Int
   in block <unit> at exceptions.pl6:2
----

You should have remarked that whenever an error occurs (in this case assigning a number to a string variable) the program will stop and other lines of code will not be evaluated, even if correct.

*Exception handling* is the process of _catching_ an exception that has been _thrown_ in order for the script to continue working.

[source,perl6]
----
my Str $name;
try {
  $name = 123;
  say "Hello " ~ $name;
  CATCH {
    default {
      say "Can you tell us your name again, we couldn't find it in the register.";
    }
  }
}
say "How are you doing today?";
----

.`Output`
----
Can you tell us your name again, we couldn't find it in the register.
How are you doing today?
----

Exception handling is done by using a `try-catch` block.

[source,perl6]
----
try {
  #code goes in here
  #if anything goes wrong, the script will enter the below CATCH block
  #if nothing goes wrong the CATCH block will be ignored
  CATCH {
    default {
      #the code in here will be evaluated only if an exception has been thrown
    }
  }
}
----

The `CATCH` block can be defined the same way a `given` block is defined.
This means we can _catch_ and handle differently many types of exceptions.

[source,perl6]
----
try {
  #code goes in here
  #if anything goes wrong, the script will enter the below CATCH block
  #if nothing goes wrong the CATCH block will be ignored
  CATCH {
    when X::AdHoc { #do something if an exception of type X::AdHoc is thrown }
    when X::IO { #do something if an exception of type X::IO is thrown }
    when X::OS { #do something if an exception of type X::OS is thrown }
    default { #do something if an exception is thrown and doesn't belong to the above types }
  }
}
----

=== Throwing Exceptions
In contrast to catching exceptions, Perl 6 also allows you to explicitly throw exceptions. +
Two types of exceptions can be thrown:

* ad-hoc exceptions

* typed exceptions

[source,perl6]
.ad-hoc
----
my Int $age = 21;
die "Error !";
----

[source,perl6]
.typed
----
my Int $age = 21;
X::AdHoc.new(payload => 'Error !').throw;
----

Ad-hoc exceptions are thrown using the `die` subroutine followed by the exception message.

Typed exceptions are objects, hence the use of the `.new()` constructor in the above example. +
All typed exceptions descend from class `X` , below are a few examples: +
`X::AdHoc` is the simplest exception type +
`X::IO` is related to IO errors +
`X::OS` is related to OS errors +
`X::Str::Numeric` related to trying to coerce a string to a number

NOTE: For a complete list of exception types and their associated methods go to https://docs.perl6.org/type-exceptions.html


== Regular Expressions
A regular expression, or _regex_ is a sequence of characters that is used for pattern matching. +
The easiest way to understand it is to think of it as a pattern.

[source,perl6]
----
if 'enlightenment' ~~ m/ light / {
    say "enlightenment contains the word light";
}
----

In this example, the smart match operator `~~` is used to check if a string (enlightenment) contains the word (light). +
"Enlightenment" is matched against a regex `m/ light /`

=== Regex definition

A regular expression can be defined as follows:

* `/light/`

* `m/light/`

* `rx/light/`

Unless specified explicitly, white space is irrelevant, `m/light/` and `m/ light /` are the same.

=== Matching characters
Alphanumeric characters and the underscore `_` are written as is. +
All other characters have to be escaped using a backslash or surrounded by quotes.

[source,perl6]
.Backslash
----
if 'Temperature: 13' ~~ m/ \: / {
    say "The string provided contains a colon :";
}
----

[source,perl6]
.Single quotes
----
if 'Age = 13' ~~ m/ '=' / {
    say "The string provided contains an equal character = ";
}
----

[source,perl6]
.Double quotes
----
if 'name@company.com' ~~ m/ "@" / {
    say "This is a valid email address because it contains an @ character";
}
----

=== Matching categories of characters
Characters can be classified into categories and we can match against them. +
We can also match against the inverse of that category (everything except it):

|===

| *Category* | *Regex* | *Inverse* | *Regex*

| Word character (letter, digit or underscore) | \w | Any character except a word character | \W

| Digit | \d | Any character except a digit | \D

| Whitespace | \s | Any character except a whitespace | \S

| Horizontal whitespace | \h | Any character except a horizontal whitespace | \H

| Vertical whitespace | \v | Any character except a vertical whitespace | \V

| Tab | \t | Any character except a Tab | \T

| New line | \n | Any character except a new line | \N

|===

[source,perl6]
----
if "John123" ~~ / \d / {
  say "This is not a valid name, numbers are not allowed";
} else {
  say "This is a valid name"
}
if "John-Doe" ~~ / \s / {
  say "This string contains whitespace";
} else {
  say "This string doesn't contain whitespace"
}
----

=== Unicode properties
Matching against categories of characters as seen in the preceding section is convenient. +
That being said, a more systematic approach would be to use of Unicode properties. +
Unicode properties are enclosed in `<: >`

[source,perl6]
----
if "John123" ~~ / <:N> / {
  say "Contains a number";
} else {
  say "Doesn't contain a number"
}
if "John-Doe" ~~ / <:Lu> / {
  say "Contains an uppercase letter";
} else {
  say "Doesn't contain an upper case letter"
}
if "John-Doe" ~~ / <:Pd> / {
  say "Contains a dash";
} else {
  say "Doesn't contain a dash"
}
----

=== Wildcards
Wildcards can also be used in a regex.

The dot `.` means any single character.

[source,perl6]
----
if 'abc' ~~ m/ a.c / {
    say "Match";
}
if 'a2c' ~~ m/ a.c / {
    say "Match";
}
if 'ac' ~~ m/ a.c / {
    say "Match";
  } else {
    say "No Match";
}
----

=== Quantifiers
Quantifiers come after a character and are used to specify how many times we are expecting it.

The question mark `?` means zero or one time.

[source,perl6]
----
if 'ac' ~~ m/ a?c / {
    say "Match";
  } else {
    say "No Match";
}
if 'c' ~~ m/ a?c / {
    say "Match";
  } else {
    say "No Match";
}
----

The star `*` means zero or multiple times.

[source,perl6]
----
if 'az' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaz' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'z' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
----

The `+` means at least one time.

[source,perl6]
----
if 'az' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaz' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'z' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
----

=== Match Results
Whenever the process of matching a string against a regex is successful,
the match result is stored in a special variable `$/`

[source,perl6]
.Script
----
if 'Rakudo is a Perl 6 compiler' ~~ m/:s Perl 6/ {
    say "The match is: " ~ $/;
    say "The string before the match is: " ~ $/.prematch;
    say "The string after the match is: " ~ $/.postmatch;
    say "The matching string starts at position: " ~ $/.from;
    say "The matching string ends at position: " ~ $/.to;
}
----

.Output
----
The match is: Perl 6
The string before the match is: Rakudo is a
The string after the match is:  compiler
The matching string starts at position: 12
The matching string ends at position: 18
----

.Explanation
`$/` returns a _Match Object_ (the string that matches the regex) +
The following methods can be called on the _Match Object_: +
`.prematch` returns the string preceding the match. +
`.postmatch` returns the string following the match. +
`.from` returns the starting position of the match. +
`.to` returns the ending position of the match. +

TIP: By default whitespace in a regex definition is irrelevant. +
If we want to match against a regex containing whitespace we have to do so explicitly. +
The `:s` in the regex `m/:s Perl 6/` forces whitespace to be considered and not discarded. +
Alternatively we could have written the regex as `m/ Perl\s6 /` and used `\s` which as we saw earlier is a placeholder for whitespace. +
If a regex contains more than a single whitespace, using `:s` becomes more effective in contrast with using `\s` for each and every whitespace.

=== Example
Lets check if an email is valid or not. +
For the sake of this example we will assume that a valid email address is formed as following: +
first name [dot] last name [at] company [dot] (com/org/net)

WARNING: The regex used in this example for email validation is not very accurate. +
Its sole purpose is to demonstrate regex functionality in Perl 6. +
Do not use it as-is in production.

[source,perl6]
.Script
----
my $email = 'john.doe@perl6.org';
my $regex = / <:L>+\.<:L>+\@<:L+:N>+\.<:L>+ /;

if $email ~~ $regex {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

.Output
`john.doe@perl6.org is a valid email`

.Explanation
`<:L>` matches a single letter +
`<:L>+` matches a single letter or more +
`\.` matches a single [dot] character +
`\@` matches a single [at] character +
`<:L+:N>` matches a letter and a number +
`<:L+:N>+` matches one or more (letters and numbers) +

The regex can be decomposed as following:

* *first name* `<:L>+`

* *[dot]* `\.`

* *last name* `<:L>+`

* *[at]* `\@`

* *company name* `<:L+:N>+`

* *[dot]* `\.`

* *com/org/net* `<:L>+`

[source,perl6]
.Alternatively a regex can be broken down into multiple named regexes
----
my $email = 'john.doe@perl6.org';
my regex many-letters { <:L>+ };
my regex dot { \. };
my regex at { \@ };
my regex many-letters-numbers { <:L+:N>+ };

if $email ~~ / <many-letters> <dot> <many-letters> <at> <many-letters-numbers> <dot> <many-letters> / {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

A named regex is defined using the following syntax: `my regex regex-name { regex definition }` +
A named regex can be called using the following syntax: `<regex-name>`

NOTE: For more info on regexes, see https://docs.perl6.org/language/regexes

== Perl 6 Modules
Perl 6 is a general purpose programming language. It can be used to tackle a multitude of tasks including:
text manipulation, graphics, web, databases, network protocols etc.

Reusability is a very important concept whereby programmers don't have to reinvent the wheel each time they want to do a new task.

Perl 6 allows the creation and redistribution of *modules*. Each module is a packaged set of functionality that can be reused once installed.

_Panda_ is a module management tool that comes with Rakudo Star.

To install a specific module, type the below command in your terminal:

`panda install "module name"`

NOTE: The Perl 6 modules directory can be found on: https://modules.perl6.org/

=== Using Modules
MD5 is a cryptographic hash function that produces a 128-bit hash value. +
MD5 has a variety of applications of which encryption of passwords stored in a database.
When a new user registers, their credentials are not stored as plain text but rather _hashed_.
The rationale behind this is that if the DB gets compromised, the attacker will not be able to know what the passwords are.

Lets say you need a script that generates the MD5 hash of a password in preparation for storing it in the DB.

Luckily there's a Perl 6 module that already implemented the MD5 algorithm. Lets install it: +
`panda install Digest::MD5`

Now run the below script:
[source,perl6]
----
use Digest::MD5;
my $password = "password123";
my $hashed-password = Digest::MD5.new.md5_hex($password);

say $hashed-password;
----
In order to run the `md5_hex()` function that creates hashes, we need to load the required module. +
The `use` keyword loads the module for use in the script.

WARNING: In practice MD5 hashing alone is not sufficient, because it is prone to dictionary attacks. +
It should be combined with a salt link:https://en.wikipedia.org/wiki/Salt_(cryptography)[https://en.wikipedia.org/wiki/Salt_(cryptography)].

== Unicode

Unicode is a standard for encoding and representing text, that caters for most writing systems in the world. +
UTF-8 is a character encoding capable of encoding all possible characters, or code points, in Unicode.

Characters are defined by a: +
*Grapheme*: Visual representation. +
*Code point*: A number assigned to the character.

=== Using Unicode

.Lets look at how we can output characters using Unicode
[source,perl6]
----
say "a";
say "\x0061";
say "\c[LATIN SMALL LETTER A]";
----
The above 3 lines showcase different ways of building a character:

. Writing the character directly (grapheme)

. Using `\x` and the code point

. Using `\c` and the code point name

.Now lets output a smiley
[source,perl6]
----
say "☺";
say "\x263a";
say "\c[WHITE SMILING FACE]";
----

.Another example combining two code points
[source,perl6]
----
say "á";
say "\x00e1";
say "\x0061\x0301";
say "\c[LATIN SMALL LETTER A WITH ACUTE]";
----

The letter `á` can be written:

* using its unique code point `\x00e1`

* or as a combination of the code points of `a` and acute `\x0061\x0301`

.Some of the methods that can be used:
[source,perl6]
----
say "á".NFC;
say "á".NFD;
say "á".uniname;
----

.`Output`
----
NFC:0x<00e1>
NFD:0x<0061 0301>
LATIN SMALL LETTER A WITH ACUTE
----

`NFC` returns the unique code point. +
`NFD` decomposes the character and return the code point of each part. +
`uniname` returns the code point name.

.Unicode letters can be used as identifiers:
[source,perl6]
----
my $Δ = 1;
$Δ++;
say $Δ;
----

.Unicode can be used to do math:
[source,perl6]
----
my $var = 2 + ⅒;
say $var;
----

== Parallelism, Concurrency and Asynchrony

=== Parallelism
Under normal circumstances, all tasks in a program run sequentially. +
This might not be a problem unless what you're trying to do is consuming a lot of time.

Naturally speaking Perl 6 has features that will enable you to run things in parallel. +
At this stage, it is important to note that parallelism can mean one of two things:

* *Task Parallelism*: Two (or more) independent expressions running in parallel.

* *Data Parallelism*: A single expression iterating over a list of elements in parallel.

Lets begin with the latter.

==== Data Parallelism
[source,perl6]
----
my @array = (0..50000);                     #Array population
my @result = @array.map({ is-prime $_ });   #call is-prime for each array element
say now - INIT now;                         #Output the time it took for the script to complete
----

.Considering the above example:
We are only doing one operation `@array.map({ is-prime $_ })` +
The `is-prime` subroutine is being called for each array element sequentially: +
`is-prime @array[0]` then `is-prime @array[1]` then `is-prime @array[2]` etc.

.Fortunately we can call `is-prime` on multiple array elements at the same time:
[source,perl6]
----
my @array = (0..50000);                         #Array population
my @result = @array.race.map({ is-prime $_ });  #call is-prime for each array element
say now - INIT now;                             #Output the time it took to complete
----

Notice the use of `race` in the expression.
This method will enable parallel iteration of the array elements.

After running both examples (with and without `race`), compare the time it took for both scripts to complete.

[TIP]
====
`race` will not preserve the order of elements. If you wish to do, so use `hyper` instead.

[source,perl6]
.race
----
my @array = (1..1000);
my @result = @array.race.map( {$_ + 1} );
@result>>.say;
----

[source,perl6]
.hyper
----
my @array = (1..1000);
my @result = @array.hyper.map( {$_ + 1} );
@result>>.say;
----

If you run both examples, you should notice that one is sorted and the other is not.

====

==== Task Parallelism

[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my @result1 = @array1.map( {is-prime($_ + 1)} );
my @result2 = @array2.map( {is-prime($_ - 1)} );

say @result1 eqv @result2;

say now - INIT now;
----

.Considering the above example:

. We defined 2 arrays

. applied a different operation for each array and stored the results

. and checked if both results are the same

The script waits for `@array1.map( {is-prime($_ + 1)} )` to finish +
and then evaluates `@array2.map( {is-prime($_ - 1)} )`

Both operations applied to each array do not depend on each other.

.Why not do both in parallel?
[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my $promise1 = start @array1.map( {is-prime($_ + 1)} ).eager;
my $promise2 = start @array2.map( {is-prime($_ - 1)} ).eager;

my @result1 = await $promise1;
my @result2 = await $promise2;

say @result1 eqv @result2;

say now - INIT now;
----

.Explanation
The `start` method evaluates the code and returns *an object of type promise* or shortly *a promise*. +
If the code is evaluated correctly, the _promise_ will be *kept*. +
If the code throws an exception, the _promise_ will be *broken*.

The `await` method waits for a *promise*. +
If it's *kept* it will get the returned values. +
If it's *broken* it will get the exception thrown.

Check the time it took each script to complete.

WARNING: Parallelism always adds a threading overhead. If that overhead is not offset by gains in computational speed, the script will seem slower. +
This is why, using `race`, `hyper`, `start` and `await` for fairly simple scripts can actually slow them down.

=== Concurrency and Asynchrony
NOTE: For more info on Concurrency and Asynchronous Programming, see https://docs.perl6.org/language/concurrency

== The Community

* link:irc://irc.freenode.net/#perl6[#perl6] IRC channel. Much discussion happens on IRC. This should be your go to place for any enquiry: https://perl6.org/community/irc

* link:http://pl6anet.org[pl6anet] blog aggregator. Stay tuned by reading blog posts that focus on Perl 6.

* link:https://www.reddit.com/r/perl6/[/r/perl6] Subscribe to the Perl 6 subreddit.
